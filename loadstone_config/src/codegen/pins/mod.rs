use crate::{port, Configuration, pins::QspiPins};
use anyhow::Result;
use quote::{format_ident, quote};
use syn::{Ident, Index};
use std::{
    fs::{File, OpenOptions},
    io::Write,
    path::Path,
    iter::empty,
};

struct SerialPinTokens {
    bank: char,
    index: Index,
    mode: Ident,
    direction: Ident,
    peripheral: Ident,
}
struct QspiFlashPinTokens {
    bank: char,
    index: Index,
    mode: Ident,
    earmark: Ident,
}

use super::prettify_file;
mod stm32;

/// Generates the `pin_configuration.rs` module, which contains pin definitions
/// alternate function assignments for a particular loadstone build.
pub fn generate<P: AsRef<Path>>(
    autogenerated_folder_path: P,
    configuration: &Configuration,
) -> Result<()> {
    let filename = autogenerated_folder_path.as_ref().join("pin_configuration.rs");
    let mut file = OpenOptions::new().write(true).create(true).truncate(true).open(&filename)?;

    match configuration.port.subfamily() {
        port::Subfamily::Stm32f4 => stm32::generate_stm32f4_pins(configuration, &mut file)?,
        port::Subfamily::Efm32Gg11 => generate_efm32gg(configuration, &mut file)?,
        port::Subfamily::Max3263 => generate_max3263(configuration, &mut file)?,
    };
    prettify_file(filename).ok();
    Ok(())
}

fn generate_efm32gg(_configuration: &Configuration, file: &mut File) -> Result<()> {
    let code = quote! {
        pub use blue_hal::hal::null::NullFlash as ExternalFlash;
    };
    file.write_all(format!("{}", code).as_bytes())?;
    Ok(())
}

fn generate_max3263(configuration: &Configuration, file: &mut File) -> Result<()> {
    let code = if configuration.memory_configuration.external_flash.is_some() {
        // NOTE: Since the IS25LP218F external flash communicated over 4-wire SPI, the underlying
        // SPI driver only expects 4 pin types, but the configuration provides 6. We can just
        // ignore the final two pins (IO2, IO3).

        let spi_pins: Vec<_> = qspi_flash_pin_tokens(configuration).map(|p| {
            format_ident!("P{}{}", p.bank, p.index)
        }).take(4).collect();

        let spi_modes: Vec<_> = qspi_flash_pin_tokens(configuration).map(|p| {
            p.mode
        }).take(4).collect();

        quote! {
            use blue_hal::drivers::{
                is25lp128f::Is25Lp128F,
                max3263::gpio::*,
            };
            pub type Spi = blue_hal::drivers::max3263::spi::Spi<#(#spi_pins<#spi_modes>,)*>;
            pub type ExternalFlash = Is25Lp128F<Spi>;

            pub fn pins() -> (#(#spi_pins<#spi_modes>,)*) {
                todo!()
            }
        }
    } else {
        quote! {
            pub use blue_hal::hal::null::NullFlash as ExternalFlash;
        }
    };

    file.write_all(format!("{}", code).as_bytes())?;
    Ok(())
}

fn qspi_flash_pin_tokens(
    configuration: &Configuration,
) -> Box<dyn Iterator<Item = QspiFlashPinTokens>> {
    if configuration.memory_configuration.external_flash.is_none() {
        return Box::new(empty());
    }

    let pins = configuration.memory_configuration.external_memory_map.pins.clone()
        .unwrap_or_else(|| QspiPins::create(configuration.port));

    Box::new(IntoIterator::into_iter([
        QspiFlashPinTokens {
            bank: pins.clk.bank.chars().next().unwrap(),
            index: (pins.clk.index as usize).into(),
            mode: format_ident!("AF{}", pins.clk.af_index),
            earmark: format_ident!("QspiClk"),
        },
        QspiFlashPinTokens {
            bank: pins.bk1_cs.bank.chars().next().unwrap(),
            index: (pins.bk1_cs.index as usize).into(),
            mode: format_ident!("AF{}", pins.bk1_cs.af_index),
            earmark: format_ident!("QspiChipSelect"),
        },
        QspiFlashPinTokens {
            bank: pins.bk1_io0.bank.chars().next().unwrap(),
            index: (pins.bk1_io0.index as usize).into(),
            mode: format_ident!("AF{}", pins.bk1_io0.af_index),
            earmark: format_ident!("QspiOutput"),
        },
        QspiFlashPinTokens {
            bank: pins.bk1_io1.bank.chars().next().unwrap(),
            index: (pins.bk1_io1.index as usize).into(),
            mode: format_ident!("AF{}", pins.bk1_io1.af_index),
            earmark: format_ident!("QspiInput"),
        },
        QspiFlashPinTokens {
            bank: pins.bk1_io2.bank.chars().next().unwrap(),
            index: (pins.bk1_io2.index as usize).into(),
            mode: format_ident!("AF{}", pins.bk1_io2.af_index),
            earmark: format_ident!("QspiSecondaryOutput"),
        },
        QspiFlashPinTokens {
            bank: pins.bk1_io3.bank.chars().next().unwrap(),
            index: (pins.bk1_io3.index as usize).into(),
            mode: format_ident!("AF{}", pins.bk1_io3.af_index),
            earmark: format_ident!("QspiSecondaryInput"),
        },
    ]))
}
