//! Generates code from parsed .ron configuration. This is where
//! concrete Loadstone modules are constructed from user configuration
//! gathered from the web app GUI.
use quote::{__private::Span, quote};
use syn::LitBool;
use std::{
    fs::{self, OpenOptions},
    io::{self, Write},
    path::Path,
    process::Command,
};

use crate::{Configuration, features::{BootMetrics, Serial}};
use anyhow::Result;

use self::linker_script::generate_linker_script;
mod memory_map;
mod linker_script;
mod pins;
mod devices;

pub fn generate_modules<P: AsRef<Path>>(
    loadstone_path: P,
    configuration: &Configuration,
) -> Result<()> {
    let autogenerated_folder_path = loadstone_path.as_ref().join("src/autogenerated");
    fs::create_dir(&autogenerated_folder_path).ok();
    generate_linker_script(&configuration)?;
    generate_top_level_module(&autogenerated_folder_path, configuration)?;
    memory_map::generate(
        &autogenerated_folder_path,
        &configuration.memory_configuration,
        &configuration.port,
    )?;
    pins::generate(&autogenerated_folder_path, &configuration)?;
    devices::generate(&autogenerated_folder_path, &configuration)?;
    Ok(())
}

fn generate_top_level_module<P: AsRef<Path>>(autogenerated_folder_path: P, configuration: &Configuration) -> Result<()> {
    let filename = autogenerated_folder_path.as_ref().join("mod.rs");
    let mut file = OpenOptions::new().write(true).create(true).truncate(true).open(&filename)?;

    let (serial_enabled, recovery_enabled)
        = if let Serial::Enabled { recovery_enabled, .. } = configuration.feature_configuration.serial {

        if !Serial::supported(&configuration.port) {
            panic!("Serial features enabled for a port that doesn't suppor them: {:?}", configuration.port);
        }
        (LitBool::new(true, Span::call_site()), LitBool::new(recovery_enabled, Span::call_site()))
    } else {
        (LitBool::new(false, Span::call_site()), LitBool::new(false, Span::call_site()))
    };

    let boot_time_metrics_enabled = if let BootMetrics::Enabled { timing: true } = &configuration.feature_configuration.boot_metrics {
        if !BootMetrics::timing_supported(&configuration.port) {
            panic!("Timing features enabled for a port that doesn't suppor them: {:?}", configuration.port);
        }
        LitBool::new(true, Span::call_site())
    } else {
        LitBool::new(false, Span::call_site())
    };

    let code = quote! {
        //! This entire module is autogenerated. Don't modify it manually!
        //! Logic for generating these files is defined under `loadstone_config/src/codegen/`
        pub mod memory_map;
        pub mod pin_configuration;
        pub mod devices;

        #[allow(unused)]
        pub const SERIAL_ENABLED: bool = #serial_enabled;
        #[allow(unused)]
        pub const RECOVERY_ENABLED: bool = #recovery_enabled;
        #[allow(unused)]
        pub const BOOT_TIME_METRICS_ENABLED: bool = #boot_time_metrics_enabled;
    };

    file.write_all(format!("{}", code).as_bytes())?;
    prettify_file(filename).ok();
    Ok(())
}

fn prettify_file<P: AsRef<Path>>(path: P) -> io::Result<()> {
    Command::new("rustfmt").arg(path.as_ref()).spawn()?.wait()?;
    Ok(())
}
