use anyhow::Result;
use quote::quote;
use std::{fs::OpenOptions, io::Write, path::Path};

use crate::{codegen::prettify::prettify_file, memory::{ExternalMemoryMap, InternalMemoryMap, MemoryConfiguration}};

pub fn generate<P: AsRef<Path>>(
    autogenerated_folder_path: P,
    memory_configuration: &MemoryConfiguration,
) -> Result<()> {
    let filename = autogenerated_folder_path.as_ref().join("memory_map.rs");
    let mut file = OpenOptions::new()
        .write(true)
        .truncate(true)
        .open(&filename)?;
    let base_index = 1usize;
    let mcu_banks = generate_mcu_banks(
        base_index,
        &memory_configuration.internal_memory_map,
        memory_configuration.golden_index)?;
    let external_banks = generate_external_banks(
        memory_configuration.internal_memory_map.banks.len() + base_index,
        &memory_configuration.external_memory_map,
        memory_configuration.golden_index
    )?;

    file.write_all(mcu_banks.as_bytes())?;
    file.write_all(external_banks.as_bytes())?;
    prettify_file(filename).unwrap();
    Ok(())
}

fn generate_external_banks(base_index: usize, map: &ExternalMemoryMap, golden_index: Option<usize>) -> Result<String> {
    let number_of_external_banks = map.banks.len();
    let index: Vec<usize> =
        map.banks.iter().enumerate().map(|(i, _)| i + base_index).collect();
    let bootable = vec![false; number_of_external_banks];
    let location: Vec<u32> = map.banks.iter().map(|b| b.start_address).collect();
    let size: Vec<usize> = map.banks.iter().map(|b| (b.size_kb * 1024) as usize).collect();
    let golden: Vec<bool> = (0..number_of_external_banks).map(|i| Some(i) == golden_index).collect();

    let code = quote! {
        const NUMBER_OF_EXTERNAL_BANKS: usize = #number_of_external_banks;
        pub static EXTERNAL_BANKS: [image::Bank<flash::Address>; NUMBER_OF_EXTERNAL_BANKS] = [
            #(image::Bank {
                index: #index,
                bootable: #bootable,
                location: #location,
                size: #size,
                is_golden: #golden,
            }),*
        ];
    };
    Ok(format!("{}", code))
}

fn generate_mcu_banks(base_index: usize, map: &InternalMemoryMap, golden_index: Option<usize>) -> Result<String> {
    let number_of_mcu_banks = map.banks.len();
    let index: Vec<usize> =
        map.banks.iter().enumerate().map(|(i, _)| i + base_index).collect();
    let bootable: Vec<bool> = (0..number_of_mcu_banks)
        .map(|i| Some(i) == map.bootable_index)
        .collect();
    let location: Vec<u32> = map.banks.iter().map(|b| b.start_address).collect();
    let size: Vec<usize> = map.banks.iter().map(|b| (b.size_kb * 1024) as usize).collect();
    let golden: Vec<bool> = (0..number_of_mcu_banks).map(|i| Some(i) == golden_index).collect();

    let code = quote! {
        const NUMBER_OF_MCU_BANKS: usize = #number_of_mcu_banks;
        pub static MCU_BANKS: [image::Bank<flash::Address>; NUMBER_OF_MCU_BANKS] = [
            #(image::Bank {
                index: #index,
                bootable: #bootable,
                location: #location,
                size: #size,
                is_golden: #golden,
            }),*
        ];
    };
    Ok(format!("{}", code))
}
