use super::update_signal::NullUpdatePlanner;
use crate::{
    devices::{bootloader::Bootloader, image::CrcImageReader as ImageReader},
    error,
    error::Error,
    ports::autogenerated::{
        devices,
        memory_map::{EXTERNAL_BANKS, MCU_BANKS},
        pin_configuration::{self, *},
        LOADSTONE_GREETING,
    },
};
use blue_hal::{
    drivers::{
        is25lp128f,
        max3263::{
            flash::{self, Flash},
            spi,
        },
    },
    hal::null::{NullError, NullSerial, NullSystick},
    max32pac,
};

impl error::Convertible for NullError {
    fn into(self) -> error::Error { panic!() }
}

impl error::Convertible for flash::Error {
    fn into(self) -> error::Error {
        match self {
            flash::Error::AddressOutOfRange => {
                error::Error::DriverError("Attempt to access invalid flash address.")
            }
            flash::Error::UnalignedAccess => {
                error::Error::DriverError("Attempt to access unaligned flash address.")
            }
            flash::Error::PageEraseFailed => error::Error::DriverError("Flash page erase failed."),
            flash::Error::MassEraseFailed => error::Error::DriverError("Flash mass erase failed."),
            flash::Error::WriteFailed => error::Error::DriverError("Flash write failed."),
        }
    }
}

impl error::Convertible for is25lp128f::Error {
    fn into(self) -> Error { todo!() }
}

impl Bootloader<ExternalFlash, Flash, NullSerial, NullSystick, ImageReader, NullUpdatePlanner> {
    pub fn new() -> Self {
        let mut peripherals = max32pac::Peripherals::take().unwrap();

        peripherals.CLKMAN.clk_ctrl.write(|w| unsafe { w.system_source_select().bits(0b01) });

        peripherals.ICC.ctrl_stat.write(|w| w.enable().set_bit());

        let (spi_clock, spi_select, spi_miso, spi_mosi) = pin_configuration::pins();

        let optional_external_flash = devices::construct_flash(
            peripherals.SPIM1,
            &mut peripherals.CLKMAN,
            spi_clock,
            spi_select,
            spi_miso,
            spi_mosi,
        );

        let mcu_flash = Flash::new(peripherals.FLC);
        Bootloader {
            mcu_flash,
            external_banks: &EXTERNAL_BANKS,
            mcu_banks: &MCU_BANKS,
            external_flash: optional_external_flash,
            serial: None,
            boot_metrics: Default::default(),
            start_time: None,
            recovery_enabled: false,
            greeting: LOADSTONE_GREETING,
            _marker: Default::default(),
            update_planner: None,
        }
    }
}
