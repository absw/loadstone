use crate::devices::bootloader::Bootloader;
use blue_hal::{
    hal::null::{NullError, NullFlash, NullSystick},
    drivers::stm32f4::{
        flash::{self, McuFlash},
        rcc::Clocks,
        serial,
    },
    stm32pac,
};
use crate::devices::{
    image::CrcImageReader as ImageReader,
};
use super::update_signal::NullUpdatePlanner;
use crate::error;
use super::autogenerated::{
    self,
    RECOVERY_ENABLED, devices,
    memory_map::{EXTERNAL_BANKS, MCU_BANKS},
    pin_configuration::{self, *},
};

impl error::Convertible for NullError {
    fn into(self) -> error::Error { panic!() }
}

impl error::Convertible for flash::Error {
    fn into(self) -> error::Error {
        todo!()
    }
}

impl Bootloader<NullFlash, McuFlash, Serial, NullSystick, ImageReader, NullUpdatePlanner> {
    pub fn new() -> Self {
        let mut peripherals = stm32pac::Peripherals::take().unwrap();
        let mcu_flash = flash::McuFlash::new(peripherals.FLASH).unwrap();

        let (serial_pins, _) = pin_configuration::pins(
            peripherals.GPIOA,
            peripherals.GPIOB,
            peripherals.GPIOC,
            peripherals.GPIOD,
            peripherals.GPIOE,
            peripherals.GPIOF,
            peripherals.GPIOG,
            peripherals.GPIOH,
            &mut peripherals.RCC,
        );
        let clocks = Clocks::hardcoded(peripherals.RCC);
        let serial = devices::construct_serial(
            serial_pins,
            clocks,
            peripherals.USART1,
            peripherals.USART2,
            peripherals.USART3,
            peripherals.UART4,
            peripherals.UART5,
            peripherals.USART6,
        );

        Bootloader {
            mcu_flash,
            external_banks: &EXTERNAL_BANKS,
            mcu_banks: &MCU_BANKS,
            external_flash: None,
            serial,
            boot_metrics: Default::default(),
            start_time: None,
            recovery_enabled: RECOVERY_ENABLED,
            greeting: autogenerated::LOADSTONE_GREETING,
            _marker: Default::default(),
            update_planner: None,
        }
    }
}

impl error::Convertible for serial::Error {
    fn into(self) -> error::Error {
        match self {
            serial::Error::Framing => error::Error::DriverError("[Serial] Framing error"),
            serial::Error::Noise => error::Error::DriverError("[Serial] Noise error"),
            serial::Error::Overrun => error::Error::DriverError("[Serial] Overrun error"),
            serial::Error::Parity => error::Error::DriverError("[Serial] Parity error"),
            serial::Error::Timeout => error::Error::DriverError("[Serial] Timeout error"),
            _ => error::Error::DriverError("[Serial] Unexpected serial error"),
        }
    }
}
