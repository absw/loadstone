//! Concrete boot manager construction and flash bank layout
//! for the [stm32f412 discovery](../../../../loadstone/hardware/discovery.pdf).
use crate::{autogenerated::devices, devices::{boot_manager::BootManager, cli::Cli}};
use blue_hal::{drivers::{micron::n25q128a_flash::MicronN25q128a, stm32f4::{flash, qspi::{self, QuadSpi, mode}, rcc::Clocks, serial::{self, UsartExt}, systick::SysTick}}, hal::time, stm32pac::{self, USART6}};

use crate::autogenerated::pin_configuration::{self, *};
use crate::autogenerated::memory_map::EXTERNAL_BANKS;
use crate::autogenerated::memory_map::MCU_BANKS;

impl Default for BootManager<flash::McuFlash, ExternalFlash, Serial> {
    fn default() -> Self { Self::new() }
}

impl BootManager<flash::McuFlash, ExternalFlash, Serial> {
    pub fn new() -> Self {
        let mut peripherals = stm32pac::Peripherals::take().unwrap();
        let cortex_peripherals = cortex_m::Peripherals::take().unwrap();
        let mcu_flash = flash::McuFlash::new(peripherals.FLASH).unwrap();
        let clocks = Clocks::hardcoded(peripherals.RCC);

        SysTick::init(cortex_peripherals.SYST, clocks);
        SysTick::wait(time::Seconds(1)); // Gives time for the flash chip to stabilize after powerup
        let (serial_pins, qspi_pins) = pin_configuration::pins(&mut peripherals);

        let serial = devices::construct_serial(serial_pins, &mut peripherals, clocks);
        let cli = Cli::new(serial).unwrap();

        let qspi_config = qspi::Config::<mode::Single>::default().with_flash_size(24).unwrap();
        let qspi = Qspi::from_config(peripherals.QUADSPI, qspi_pins, qspi_config).unwrap();
        let external_flash = ExternalFlash::with_timeout(qspi, time::Milliseconds(5000)).unwrap();

        BootManager {
            external_flash: Some(external_flash),
            mcu_flash,
            external_banks: &EXTERNAL_BANKS,
            mcu_banks: &MCU_BANKS,
            cli: Some(cli),
            boot_metrics: None
        }
    }
}
